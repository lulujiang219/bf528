# Again, we specify the base file names which will serve to inform snakemake to the appopriate
# wildcards it will ultimately end up determining. We will discuss more elegant ways to do this
# for project 2 that doesn't involve creating a python list in every snakefile. 

NAMES = ['ADrep1subsample', 'ADrep2subsample', 'P0rep1subsample', 'P0rep2subsample', 'P4rep1subsample', 'P4rep2subsample', 'P7rep1subsample', 'P7rep2subsample']


# Here we're specifying two different files as our target outputs. Remember that intermediate files
# will be generated automatically due to the idea of dependencies. We specify our single output,
# verse_concat_filtered.csv and because the inputs/outputs of rule filter_cts, rule concat_verse,
# rule verse are all linked together, snakemake will automatically recognize that it first needs
# to run VERSE on all 8 bam files, then when ALL 8 of them exist, it can run rule concat_verse,
# which takes the information in these separate files and concatenates them into a single matrix. 
# Finally, it can generate verse_concat_filtered.csv if and only if verse_concat.csv exists first.
# verse_concat_filtered.csv is simply a filtered version of the full file, verse_concat.csv, and so
# logically it cannot exist unless the full file exists first. 

# The id2gene.txt file is generated by its own rule and does not DEPEND on any of the other rules 
# or tasks found in this file. We can create the id2gene.txt file as soon as the input to this rule
# exists. In the case of rule txn_mapping, it requires the gencode primary assembly GTF file to generate
# this output. From last week, we should have already downloaded and decompressed this file and so 
# snakemake correctly recognizes this file exists and can run rule txn_mapping immediately. If you were
# to parallelize these tasks, the rule txn_mapping could run at the very start since it depends on files
# that already exist and not on any of the outputs of any of the other rules.

rule all:
	input:
		'results/verse_concat_filtered.csv',
		'results/id2gene.txt',

# You can run VERSE with default parameters. The counting strategy for RNAseq has been validated
# and peer-reviewed over time. The two important flags to remember are -S (the manual states that
# if your BAM files are not sorted by name, you need to specify this option) and the -o flag, which 
# takes ONLY the prefix of the output it will create. By default, VERSE will automatically remove
# the file extension from the bam and append (.exon.txt). 

rule verse:
	input:
		bam = 'results/{name}.Aligned.out.bam',
		gtf = 'results/gencode.vM33.primary_assembly.annotation.gtf',
	output:
		verse_exons = 'results/{name}.exon.txt'
	params:
		prefix = 'results/{name}'
	shell:
		'verse -S -a {input.gtf} -o {params.prefix} {input.bam}'

# Here we have an expand() statement in our INPUT. Remember that expand() statements functionally
# create a python list of strings with the specified pattern. By using this expand() in this input
# we are implicitly instructing snakemake to wait until ALL 8 .exon.txt files exist. You can see 
# that these are the output from the previous rule, verse. Because we only want this rule to run
# when all 8 files exist, we provide it a list of all the files that need to exist before we can
# concatenate them together. Since our goal is to concatenate all 8 samples together, they all
# need to exist before this can occur. If we were to not use an expand() statement here and instead
# our input was:
#
# mats = 'results/{name}.exon.txt'
#
# Snakemake would attempt to run this rule, concat_verse, 8 times, after each VERSE output has been
# produced. Since we are interested in concatenating all 8 files together, we do not want this rule
# to run on individual files 8 times. We want it to run once on all 8 files.

rule concat_verse:
	input:
		mats = expand('results/{name}.exon.txt', name=NAMES)
	output:
		concat = 'results/verse_concat.csv'
	shell:
		'''
		python concat_df.py -i {input.mats} -o {output.concat}
		'''

# The goal of your filter_cts_mat.py script was to filter your matrix to only retain genes
# where all 8 samples have a non-zero count. This choice was a subjective choice and you should
# determine this filter / threshold on an experiment by experiment basis. I chose this filter to 
# ensure that, at worst, we are comparing 2 samples vs 2 samples (no zeros). This experiment unfortunately
# did not have a large amount of biological replicates and so this filter was chosen to mitigate
# some of the uncertainty. 

# I personally chose to use pandas to accomplish this. Essentially, I read in the entire matrix
# as a dataframe. I then used a boolean expression across each row where True represented a non-zero
# count for a sample and False represented a zero count. Because we can also represent boolean values of
# true and false in python as 1 and 0, I then counted across the row. Rows that "summed" to 8 were rows
# or genes where every sample had a nonzero count. I used the .loc function to keep only those rows and
# discarded the rest.
#
# You could likely have also done this in plain python. Remember the verse_concat.csv is a simple comma
# delimited file. You could have used python to iterate row by row, split by the comma (or whatever delimiter)
# and count how many 0s and nonzeros you have in each row. You would then save the rows where all 8 samples
# are nonzero to a list or simply write them out to the new file as you go. 

rule filter_cts:
	input:
		verse = 'results/verse_concat.csv'
	output:
		filtered = 'results/verse_concat_filtered.csv'
	shell:
		'''
		python filter_cts_mat.py -i {input.verse} -o {output.filtered}
		'''

# There were many ways to accomplish this goal. Remember it does not matter how you did it as long
# as you got the right result. Do not feel like you need to adjust your code based on my way of doing it.
# There are many ways to arrive at the same answer, and all are equally valid. As you progress in your 
# career, you will continue to refine and develop your coding skills. I chose to solve this problem 
# in two different ways: one that makes use of regular expressions to capture the geneid and gene name,
# and the second that uses split() and strip() to accomplish the same thing. The goal was to end up with
# a txt file (delimited file) where each row represents a gene id (ENSMUSGXXXXX) and it's corresponding
# human digestible gene name (GPS2). 

rule txn_mapping:
	input:
		gtf = 'results/gencode.vM33.primary_assembly.annotation.gtf'
	output:
		mapping = 'results/id2gene.txt'
	shell:
		'''
		python parse_gtf.py -i {input.gtf} -o {output.mapping}
		'''

